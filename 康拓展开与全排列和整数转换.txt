康托展开公式
X=an*(n-1)!+an-1*(n-2)!+...+ai*(i-1)!+...+a2*1!+a1*0! 其中，a为整数，并且0<=ai<i(1<=i<=n)。这就是康托展开。
康托展开是一个全排列到一个自然数的双射，常用于构建哈希表时的空间压缩。 康托展开的实质是计算当前排列在所有由小到大全排列中的顺序，因此是可逆的。
康拓展开实例
{1,2,3,4,...,n}表示1,2,3,...,n的排列如 {1,2,3} 按从小到大排列一共6个。123 132 213 231 312 321 。
代表的数字 1 2 3 4 5 6 也就是把10进制数与一个排列对应起来。
他们间的对应关系可由康托展开来找到。
如我想知道321是{1,2,3}中第几个大的数可以这样考虑 ：
第一位是3，当第一位的数小于3时，那排列数小于321 如 123、 213 ，小于3的数有1、2 。所以有2*2!个。再看小于第二位2的：小于2的数只有一个就是1 ，所以有1*1!=1 
所以小于321的{1,2,3}排列数有2*2!+1*1!=5个。所以321是第6个大的数。 2*2!+1*1!+1*0!就是康托展开。
再举个例子：1324是{1,2,3,4}排列数中第几个大的数：第一位是1小于1的数没有，是0个 0*3! 第二位是3小于3的数有1和2，但1已经在第一位了，
所以只有一个数2 1*2! 。第三位是2小于2的数是1，但1在第一位，所以有0个数 0*1! ，
所以比1324小的排列有0*3!+1*2!+0*1!=2个，1324是第三个大数。

代码描述:

假设我们求一个12位数排列 对应的整数转换

const int PermSize=12;
long long f[PerSize]={1,1,2,6,24,120,720, 5040, 40320, 362880, 3628800,39916800}   //列出从0!,1!,2!....(n-1)!

long long contor(String buf)
{
   int i,j,count;
   int result=0;
   for(i=0;i<PermSize;i++)
   {   
          count=0;
      for(j=i+1;j<PermSize;j++)
          if(buf[i]>buf[j])
            count++;
      result=result+count*f[PermSize-i-1];
   }
   return result;
}

这样我们就能把一个字符串数列转换成一个唯一的整数，并且这个整数表示在由该字符串中
出现的数字组成的全排列(字典序)中该串所表示的数是全排列中的第几个数。


二.全排列的解码 康拓展开逆运算

如何找出第16个（按字典序的）{1,2,3,4,5}的全排列？
 
1. 首先用16-1得到15
 
2. 用15去除4! 得到0余15
 
3. 用15去除3! 得到2余3
 
4. 用3去除2! 得到1余1
 
5. 用1去除1! 得到1余0
 
有0个数比它小的数是1，所以第一位是1
 
有2个数比它小的数是3，但1已经在之前出现过了所以是4
 
有1个数比它小的数是2，但1已经在之前出现过了所以是3
 
有1个数比它小的数是2，但1,3,4都出现过了所以是5
 
最后一个数只能是2
 
所以排列为1 4 3 5 2

代码：


const int fac[] = {1, 1, 2, 6, 24, 120, 720, 5040, 40320};///阶乘
bool vis[10];

void invKT(int ans[],int n,int k)//ans[]存贮找到的对应数，n表示{1,2,3...n}，k表示的是找出第k个
{ 
   int i,j,t;
   k--;
   memset(vis,false,sizeof(vis)); 
  for(i=0;i<n;i++)
   {
      t=k/fac[n-i-1];//除法
      for(j=1;j<=n;j++)//找满足比对应数字小的数
      if(!vis[j])
      { 
       if(t==0)break;
        t--;
      }
     ans[i]=j;
     vis[j]=true;
     k=k%fac[n-i-1];//求余数  
   }
}






